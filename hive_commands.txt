#To get hive command prompt
    $hive

#To see all databases
    >show databases;

#To create database my_database
    >create database my_database
    /* when we create a databse, it will have path /user/hive/warehouse/my_database.db/

#To create database if its not exists
    >create database if not exists my_database;

#To see databases whose names start with m 
    >show databases like 'm*';

#To save the databse in given directory
    > CREATE DATABASE dir1 LOCATION '/ana';

#To create database with comment
    >create database dir1 comment 'give your comment here';

#To delete databse with files in it
    >drop database if exists dir1 cascade; 

#To delete database without files
    >drop databse if exists dir2

#To use a database named my_database
    >use my_database

#To see tables inside selected database
    >show tables;
    /* if this step performed without selecting the database tables in default database will be displayed*/

#to copy table schema(not data)
    >CREATE TABLE IF NOT EXISTS dir1.employees2 LIKE dir2.employees;

#create table
    >create table if not exists table1(name string comment 'emp name',salary float comment 'emp salary',subordinates array<string> comment 'name of subordinates',desuctions map<string,float> comment 'keys are names and values are percentage' ,address struct<street:string,zip:int> comment 'address') comment 'table' location '/user/hive/warehouse/mydb.db/table1';

#To visualize all data in table1
    >select * from table1;

#To create a table called table1 with roll_no(integer) as a primary key,name varchar
    >create table table1 (roll_no int primary key,name string);

#To load data from a data.csv to table1
    >create table table1 (roll_no int primary key,name string) row format delimited fields terminated by '\t';
    >load data local inpath '/home/training/data.csv' into table table1;

#To describe a table
    > describe tabel

#external table
    >create external table if not exists frnds(id int,name string,age int,job string) row format delimited fields terminated by '\t' location '/anna';
    >load data local inpath '/home/training/myfile.csv' into table frnds;

#copy schema of external table
    > create external table new_table like frnds location '/vit';

#PARTITIONS
    >create table a5(id int,name string,age int)partitioned by (job_name string) row format delimited fields terminated by '\t';
    >load data local inpath '/home/training/zakku/engineer' into table a5 partition(job_name="engineer"); 
    >load data local inpath '/home/training/zakku/developer' into table a5 partition(job_name="developer"); 
    >load data local inpath '/home/training/zakku/dancer' into table a5 partition(job_name="dancer"); 
    /*creates 3 partition..
    >select * from a5 where job_name="dancer";
    /*because of partition select statement takes less time ..same works for external tables also

#to see partitions of a table named a5
    >show partitions a5;

#to delete a partition
    >alter table a5 drop if exists partition(job_name="dancer");

#to add a partition
    >alter table a5 add if not exists partition(job_name="dancer") location '/home/training/zakku/dancer';

#dynamic partition
    >create table new_t (id int,name string,age int) partitioned by(jobs string);
    >set hive.exec.dynamic.partition.mode=nonstrict;
    >insert into table new_t partition (jobs) select id,name,age,job from t6;


#to get top n numbers(here 2)
    >select * from a5 limit 2;

#to delete a table
    >drop table if exists table1

#to rename a table
    >alter table old_name rename to new_table

#to change column name
    >alter table a3 change column name new_name string comment 'update' after id;
    /* oldname newname datatype ..after and comment is not necessary

#to add new column in table
    >alter table a3 add columns(new_col string comment 'new column');
    /*columnname type comment

#select statement
    >select id,name from t1;
                OR
    >SELECT e.name, e.salary FROM employees e;

#to capitalize string type column values
    >select upper(name) from t1;

#to make string lowercase
    >select lower(name) from t1;

#to round mathematical operation
    >select round(id/2) from t1;

#nested select
    > from(select id,name from t1)e select e.id,upper(e.name) where id>2;

#when then
    >   SELECT name, salary,
        CASE
        WHEN salary < 50000.0 THEN 'low'
        WHEN salary >= 50000.0 AND salary < 70000.0 THEN 'middle'
        WHEN salary >= 70000.0 AND salary < 100000.0 THEN 'high'
        ELSE 'very high'
        END AS bracket FROM employees;
    /*here bracket is part of syntax

#where
    >select * from emp where id>1;

#comparing with float numbers
    >select id from t1 where id> cast(1.5 as float);
    /*cast(number as float)
    
#like
    >select name from t1 where name like '%a';

#rlike
    >select name from t1 where name rlike '(a|g).*';
    /*for regular expression. A period (.) matches
    /*any character and a star (*) means repeat the “thing to the left” (period, in the two cases
    /*shown) zero to many times. The expression (x|y) means match either x or y.

#group by
    >select avg(age)  from t1 group by job ;

#having
    >select avg(age)  from t1 group by job having avg(age)>22;
    /*to  constrain the groups produced by GROUP BY

#inner join
    >select a.name,a.id,b.place from t1 a join t2 b on a.id=b.id;
    /*t1 and t2 are tables..same for external tables

#inner join with 3 tables
    >select a.name,b.place,c.age from t1 a join t2 b on a.id=b.id join t3 c on b.id=c.id;

#left join
    >select a.name,b.pos from t1 a left outer join t4 b on a.id=b.id;
    /*n this join, all the records from the lefthand table that match the WHERE clause are returned. If the righthand table doesn’t have a record that matches the ON criteria,
    /*NULL is used for each column selected from the righthand table.

#right join
    >select a.name,b.pos from t4 a right outer join t1 b on a.id=b.id;
    /*Right-outer joins return all records in the righthand table that match the WHERE clause.
    /*NULL is used for fields of missing records in the lefthand table

#full join
    > select b.name,a.pos from t4 a full outer join t1 b on a.id=b.id;
    /*inally, a full-outer join returns all records from all tables that match the WHERE clause.
    /*NULL is used for fields in missing records in either table.

#left semi join
    >select a.name from t6 a left semi join t4 b on a.id=b.id;
    /* left semi-join returns records from the lefthand table if records are found in the righthand table that satisfy the ON predicates
    /*ote that the SELECT and WHERE clauses can’t reference columns from the righthand table

#cartesian product join
    >SELECT * FROM stocks JOIN dividends;
    /* Cartesian product is a join where all the tuples in the left side of the join are paired with all the tuples of the right table.
     /*If the left table has 5 rows and the right table has

6 rows, 30 rows of output will be produced
#order by
    > select name,id from t6 order by id asc; /* order by id in ascending
    > select name,id from t6 order by id desc; /* order by id in descending
    > select name,id,age from t6 order by age asc,id desc; /* order by age in descending..for all repeating values order by id

#sort by
    > select name,id from t6 sort by id asc; /* sort by id in ascending
    > select name,id from t6 sort by id desc; /* sort by id in descending
    > select name,id,age from t6 sort by age asc,id desc; /* sort by age in descending..for all repeating values order by id


#views
    >create view q1 as
     select a.name,b.place     
     from t6 a join t4 b on(a.id=b.id);

#deleting view
    >DROP VIEW IF EXISTS shipments;






















#To create a table in hive and add data to it from .csv file
    >create table table1(id int,name string) row format delimited fields terminated by ',';
    >load data local inpath '/home/training/file1.csv' into table table1;
    >select id,name from table1;

#counting characters
    $vi story.txt
    $hdfs dfs -mkdir /story
    $hdfs dfs -put story.txt /story/

    > create table input(text_lines string);
    >load data inpath '/story' into table input;
    >create table wordcount as select word,count(*) from input LATERAL VIEW explode(split(text_lines,' ')) 1table as word group by word;

            OR(THE LAST LINE FROM ABOVE SECTION CAN BE REPLACED BY)

    >select split(text_lines,' ') from input;    
    >create view input_split as select split(text_lines,' ') as word from input;
    >select explode(word) as w from input_split;   
    >create view input_explode as select explode(word) as w from input_split;
    >select w,count(*) from input_explode group by w;
            OR(ZAKKU'S VERSION)

    >create view count_pro as
     select explode(split(lin,' ')) as w from story1;
    >select w,count(*) from count_pro group by w;

    2)total words in each sentence
    >create table story1(lin string); 
    >load data local inpath '/home/training/zakku/story.txt' into table story1;
    >select size(split(lin,' ')) from story1;

    3)size of each sentence
    >select length(lin) from story1;


#To see records within given limit   
    >select * from input limit 1;   /*gives first record..if limit2 give 2 records

    
 #movie
    $create database movie;
    $create table movie(mid int,mname string,year string) row format delimited fields terminated by '\t';
    $load data inpath '/movie_data/movie/' into table movie; /*to give inpath the file should be in hdfs..if file in linux use local inpath
    $create table genre(gid int,genre string) row format delimited fields terminated by '\t';
    $load data inpath '/movie_data/genre/' into table genre;
    $create table moviegenre(mid int,gid int) row format delimited fields terminated by '\t';
    $load data inpath '/movie_data/moviegenre/' into table moviegenre;
    $create table movierating(uid int,mid int,rating int) row format delimited fields terminated by '\t';
    $load data inpath '/movie_data/movierating/' into table movierating;
    1) how many movies were relieased in a year
        $select year,count(*) from movie group by year;
    2)year with maximum movies
        $ select year,count(*) as nom from movie group by year order by nom desc limit 3;

    3)which genre has maximum movies
        $select g.genre,count(*) as nom from genre g join moviegenre mg on (g.gid=mg.gid) join movie m on (m.mid=mg.mid) group by g.genre;      /*total number in each genre
        $select g.genre,count(*) as nom from genre g join moviegenre mg on (g.gid=mg.gid) join movie m on (m.mid=mg.mid) group by g.genre order by nom limit 1;

            OR 
        >select a.n,b.genre                                          
        from(select count(*) as n,gid from moviegenre group by gid)a join genre b on (a.gid=b.gid) 
        order by a.n desc limit 1; 

    3)which movie is of which genre?
        $select m.mname,g.genre from movie m join moviegenre mg on (m.mid=mg.mid) join genre g on (g.gid=mg.gid);

            OR
        >select a.mname,b.genre
        from movie a join moviegenre c on a.mid=c.mid left outer join genre b on c.gid=b.gid;

    4)in 2000,how many movies were under genre comedy?
        >select count(*) 
        from movie a join moviegenre c on a.mid=c.mid left outer join genre b on c.gid=b.gid
        where a.year=2000 and b.genre="Comedy";  
        
#we can see all tables in mysql metadata by typing this in mysql
    use metastore
    select * from TBLS;






#hive dynamic partition

#bucketing

create view moviecomp as select m.mid,m.mname,m.year,g.gid,g.genre from movie m join moviegenre mg on (m.mid=mg.mid) join genre g on (g.gid=mg.gid);
describe moviecomp;
create table moviebucket (mid int,mname string,year string,gid int,gname string) clustered by (year) into 5 buckets;
insert into table moviebucket select * from moviecomp;




